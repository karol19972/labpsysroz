/*-
 * Copyright (C) 2011, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This file was distributed by Oracle as part of a version of Oracle NoSQL
 * Database made available at:
 *
 * http://www.oracle.com/technetwork/database/database-technologies/nosqldb/downloads/index.html
 *
 * Please see the LICENSE file included in the top-level directory of the
 * appropriate version of Oracle NoSQL Database for a copy of the license and
 * additional information.
 */

package oracle.kv.impl.query.runtime;

import static oracle.kv.impl.util.SerialVersion.QUERY_VERSION_6;
import static oracle.kv.impl.util.SerialVersion.QUERY_VERSION_7;
import static oracle.kv.impl.util.SerialVersion.QUERY_VERSION_9;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import oracle.kv.Direction;
import oracle.kv.impl.api.table.DisplayFormatter;
import oracle.kv.impl.api.table.FieldValueImpl;
import oracle.kv.impl.api.table.IndexImpl;
import oracle.kv.impl.api.table.NameUtils;
import oracle.kv.impl.api.table.RecordDefImpl;
import oracle.kv.impl.api.table.RecordValueImpl;
import oracle.kv.impl.api.table.TableImpl;
import oracle.kv.impl.query.QueryException;
import oracle.kv.impl.query.compiler.ExprBaseTable;
import oracle.kv.impl.query.compiler.ExprInOp.In3BindInfo;
import oracle.kv.impl.query.compiler.ExprVar;
import oracle.kv.impl.query.compiler.FuncCompOp;
import oracle.kv.impl.query.compiler.FunctionLib.FuncCode;
import oracle.kv.impl.util.SerialVersion;
import oracle.kv.impl.util.SerializationUtil;
import oracle.kv.table.FieldRange;

/**
 * BaseTableIter performs table scans via the primary or a secondary index of
 * the table.
 *
 * The query plan generated by the compiler includes instances of BaseTableIter,
 * but the actual work is done by a ServerTableIter instance, which is created
 * during BaseTableIter.open(). After the creation of the worker iter, the
 * open/next/reset/close methods of BaseTableIter are propagated to that
 * worker. The reason for this separation is that ServerTableIter uses
 * server-side classes, which are not available in the client jar.
 *
 * ServerIterFactory is an interface whose createTableIterator() method
 * does the job of creating the worker iter. Specifically, when the RCB is
 * created at the server, an instance of ServerIterFactoryImpl is also created
 * and stored in the RCB. Then, during BaseTableIter.open() the
 * ServerIterFactoryImpl stored in the RCB is used to create the
 * ServerTableIter.
 */
public class BaseTableIter extends PlanIter {

    public static class TableIterState extends PlanIterState {

        PlanIter theWorkerIter;

        public TableIterState(PlanIter worker) {
            theWorkerIter = worker;
        }
    }

    protected final String theNamespace;

    protected final String[] theTableNames; // changed in QUERY_VERSION_6

    protected final String[] theTableAliases; // added in QUERY_VERSION_9

    protected final int theNumAncestors; // added in QUERY_VERSION_6

    protected final int theNumDescendants; // added in QUERY_VERSION_6

    protected final String theIndexName;

    /*
     * The definition of the data returned by this iterator.
     */
    protected final RecordDefImpl theTypeDef;

    /*
     * The direction of the table scan
     */
    protected final Direction theDirection;

    /*
     * The primary keys to use in accessing the base table. This will be null if
     * a secondary index must be used to access the table. It will be empty
     * if the primary index must be used to access the table, but there were
     * no equality predicates on primary-key columns to be pushed into the
     * primary index scan.
     *
     * Note: the keys are stored here as RecordValues, instead of PrimaryKeys,
     * for 2 reasons:
     * - When we serialize the BaseTableIter, we don't want to serialize a
     *   PrimaryKey, because that contains a TableImpl as well.
     * - thePrimKeys may include "placeholder" values that correspod to external
     *   variables. As a result, a new primary key instance must be created and
     *   stored in the plan state during the open() method. This new instance
     *   will actually be an instance of PrimaryKey.
     */
    protected final RecordValueImpl[] thePrimKeys;

    /*
     * The secondary keys to use in accessing the base table. This will be null
     * if the primary index must be used to access the table. It will be empty
     * if a secondary index must be used to access the table, but there were
     * no equality predicates on secondary index columns to be pushed into the
     * index scan.
     *
     * Note: theSecKey is stored here as a RecordValue, instead of IndexKey,
     * for the same reasons described above for thePrimKey.
     */
    protected final RecordValueImpl[] theSecKeys;

    /*
     * An optional key range
     */
    protected final FieldRange[] theRanges;

    /*
     * The iterators computing values that must be bound into
     * thePrimKeys/theSecKeys and/or theRanges.
     * Added in v20.1
     */
    protected PlanIter[] theExternalKeysIters;

    /*
     * Maps the positiona od placeholder values in thePrimKeys/theSecKeys and/or
     * theRanges to iters in theExternalKeysIters.
     * Added in v20.1.
     */
    protected final int[][] theExternalKeysMap;

    /*
     * Added in v20.1.
     */
    protected final In3BindInfo[] theIn3BindInfos;

    /*
     * Added in v20.1.
     */
    protected final boolean theHaveINstartstopPreds;

    /*
     * Used before v20.1, instead of theExternalKeysIters and theExternalKeysMap
     */
    protected PlanIter[][] thePushedExternals;

    /*
     * thePredIters has an entry for each table. The entry is non-null if
     * there is a predicate that filters index or table rows during the scan
     * of the associated table. For the target table, the pred is always an
     * index-only pred that has been pushed down from the WHERE clause. For
     * the non-target tables, the pred is the ON pred, if any, associated
     * with the table.
     */
    protected PlanIter[] thePredIters; // changed in QUERY_VERSION_6

    /*
     * For each tale, it tells whether the index used to access the table
     * is a covering index or not.
     */
    protected final boolean[] theUsesCoveringIndex;

    /*
     * True if the table will be accessed via a multikey index in a way that
     * may generate duplicate table rows. Such duplicates should be eliminated.
     *
     * added in QUERY_VERSION_2
     */
    protected final boolean theEliminateIndexDups;

    /*
     * added in QUERY_VERSION_5
     */
    protected final boolean theIsUpdate;

    /*
     * added in 18.3
     */
    protected final boolean theIsDelete;

    /*
     * theTupleRegs are used differently depending on whether the iter accesses
     * a single table or implements a NESTED TABLES clause. In the 1st case, it
     * stores the columns of the current table row, so the number of regs is
     * equal to the number of table columns. In the 2nd case, the current table
     * row from each table, so the number of regs is equal to the number of
     * tables.
     */
    protected final int[] theTupleRegs;

    /*
     * theIndexTupleRegs are used for the target table only, when the index used
     * to access the table is a secondary one and the index is covering or the
     * query has index-only  filtering preds. In these cases, theIndexTupleRegs
     * store the columns of the current index entry.
     */
    protected int[] theIndexTupleRegs; // added in QUERY_VERSION_6

    protected int theIndexResultReg; // added in QUERY_VERSION_6

    protected short theVersion; // added in QUERY_VERSION_6

    /**
     * Constructor used by compiler during code generation.
     *
     * primKey and secKey will be both null if no predicates were pushed to
     * either the primary or any secondary index. In this case, an empty
     * primary key is created by this constructor, so that the table will be
     * accessed via a full scan of the primary index. If a range exists,
     * either primKey or secKey will be non-null to indicate whether the
     * range is over the primary or a secondary index. But the given key will
     * be empty, if no equality predicates were pushed to the index.
     */
    public BaseTableIter(
        ExprBaseTable e,
        int resultReg,
        int[] tupleRegs,
        TableImpl table,
        List<TableImpl> tables,
        List<String> aliases,
        int numAncestors,
        int numDescendants,
        Direction dir,
        IndexImpl index,
        ArrayList<RecordValueImpl> indexKeys,
        ArrayList<FieldRange> ranges,
        PlanIter[] externalKeysIters,
        boolean[] coveringIndexes,
        boolean eliminateIndexDups,
        boolean isUpdate,
        boolean isDelete) {

        super(e, resultReg);

        theNamespace = table.getInternalNamespace();
        theTableNames = new String[tables.size()];
        theTableAliases = new String[tables.size()];

        for (int i = 0; i < tables.size(); ++i) {
            theTableNames[i] = tables.get(i).getFullName();
            theTableAliases[i] = ExprVar.
                                 createVarNameFromTableAlias(aliases.get(i));
        }
        theNumAncestors = numAncestors;
        theNumDescendants = numDescendants;

        theTypeDef = (RecordDefImpl) e.getType().getDef();

        theDirection = dir;

        int numScans = 1;

        if (index == null && indexKeys == null) {
            theSecKeys = null;
            theIndexName = null;
            thePrimKeys = new RecordValueImpl[numScans];
            theRanges = new FieldRange[numScans];
            thePrimKeys[0] = table.createPrimaryKey();
            theRanges[0] = null;

        } else if (index == null) {
            theSecKeys = null;
            theIndexName = null;
            numScans = ranges.size();
            thePrimKeys = new RecordValueImpl[numScans];
            theRanges = new FieldRange[numScans];

            for (int i = 0; i < numScans; ++i) {
                thePrimKeys[i] = table.createPrimaryKey();
                thePrimKeys[i].copyFrom(indexKeys.get(i));
                theRanges[i] = ranges.get(i);
            }

        } else {
            thePrimKeys = null;
            theIndexName = index.getName();
            numScans = ranges.size();
            theSecKeys = new RecordValueImpl[numScans];
            theRanges = new FieldRange[numScans];

            for (int i = 0; i < numScans; ++i) {
                theSecKeys[i] = indexKeys.get(i).clone();
                theRanges[i] = ranges.get(i);
            }
        }

        theExternalKeysIters = externalKeysIters;
        theExternalKeysMap = e.getBindKeysMap();
        theHaveINstartstopPreds = e.getHaveINstartstopPreds();
        ArrayList<In3BindInfo> in3bis = e.getIn3BindInfos();
        if (in3bis != null) {
            theIn3BindInfos = new In3BindInfo[in3bis.size()];
            in3bis.toArray(theIn3BindInfos);
        } else {
            theIn3BindInfos = null;
        }

        thePredIters = new PlanIter[theTableNames.length];

        theUsesCoveringIndex = coveringIndexes;
        theEliminateIndexDups = eliminateIndexDups;
        theIsUpdate = isUpdate;
        theIsDelete = isDelete;

        theTupleRegs = tupleRegs;
    }

    /**
     * Constructor called during creation of ServerTableIter.
     */
    protected BaseTableIter(BaseTableIter parent) {

        super(parent.theStatePos, parent.theResultReg, parent.theLocation);

        theNamespace = parent.theNamespace;
        theTableNames = parent.theTableNames;
        theTableAliases = parent.theTableAliases;
        thePredIters = parent.thePredIters;
        theNumAncestors = parent.theNumAncestors;
        theNumDescendants = parent.theNumDescendants;
        theIndexName = parent.theIndexName;

        theTypeDef = parent.theTypeDef;

        theDirection = parent.theDirection;

        thePrimKeys = parent.thePrimKeys;
        theSecKeys = parent.theSecKeys;
        theRanges = parent.theRanges;

        theUsesCoveringIndex = parent.theUsesCoveringIndex;
        theEliminateIndexDups = parent.theEliminateIndexDups;
        theIsUpdate = parent.theIsUpdate;
        theIsDelete = parent.theIsDelete;

        theExternalKeysIters = parent.theExternalKeysIters;
        theExternalKeysMap = parent.theExternalKeysMap;

        theIn3BindInfos = parent.theIn3BindInfos;
        thePushedExternals = parent.thePushedExternals;
        theHaveINstartstopPreds = parent.theHaveINstartstopPreds;
        theTupleRegs = parent.theTupleRegs;
        theIndexResultReg = parent.theIndexResultReg;
        theIndexTupleRegs = parent.theIndexTupleRegs;

        theVersion = parent.theVersion;
    }

    BaseTableIter(DataInput in, short serialVersion) throws IOException {

        super(in, serialVersion);

        theVersion = serialVersion;

        theNamespace = SerializationUtil.readString(in, serialVersion);

        if (serialVersion >= QUERY_VERSION_6) {
            theTableNames = PlanIter.deserializeStringArray(in, serialVersion);
            if (serialVersion >= QUERY_VERSION_9) {
                theTableAliases = PlanIter.
                                  deserializeStringArray(in, serialVersion);
            } else {
                theTableAliases = null;
            }
            theNumAncestors = in.readInt();
            theNumDescendants = in.readInt();
        } else {
            theTableNames = new String[1];
            theTableNames[0] = SerializationUtil.readString(in, serialVersion);
            theTableAliases = null;
            theNumAncestors = 0;
            theNumDescendants = 0;
        }

        theIndexName = SerializationUtil.readString(in, serialVersion);

        theTypeDef = (RecordDefImpl)deserializeFieldDef(in, serialVersion);
        short ordinal = readOrdinal(in, Direction.values().length);
        theDirection = Direction.valueOf(ordinal);

        final int numScans = readPositiveInt(in);

        if (theIndexName == null) {
            thePrimKeys = new RecordValueImpl[numScans];
            for (int i = 0; i < numScans; ++i) {
                thePrimKeys[i] = deserializeKey(in, serialVersion);
            }
            theSecKeys = null;
        } else {
            thePrimKeys = null;
            theSecKeys = new RecordValueImpl[numScans];
            for (int i = 0; i < numScans; ++i) {
                theSecKeys[i] = deserializeKey(in, serialVersion);
            }
        }

        theRanges = new FieldRange[numScans];
        for (int i = 0; i < numScans; ++i) {
            theRanges[i] = deserializeFieldRange(in, serialVersion);
        }

        if (serialVersion >= QUERY_VERSION_6) {
            theUsesCoveringIndex = PlanIter.deserializeBooleanArray(in);
        } else {
            theUsesCoveringIndex = new boolean[1];
            theUsesCoveringIndex[0] = in.readBoolean();
        }

        theEliminateIndexDups = in.readBoolean();
        theIsUpdate = in.readBoolean();

        if (serialVersion < QUERY_VERSION_7) {
            theIsDelete = false;
        } else {
            theIsDelete = in.readBoolean();
        }

        if (serialVersion < QUERY_VERSION_9) {

            thePushedExternals = new PlanIter[numScans][];
            for (int i = 0; i < numScans; ++i) {
                thePushedExternals[i] = deserializeIters(in, serialVersion);
            }
            theExternalKeysIters = null;
            theExternalKeysMap = null;
            theIn3BindInfos = null;
            theHaveINstartstopPreds = false;

        } else {
            thePushedExternals = null;
            theHaveINstartstopPreds = in.readBoolean();
            theExternalKeysIters = deserializeIters(in, serialVersion);

            if (theExternalKeysIters.length > 0) {

                theExternalKeysMap = new int[numScans][];
                for (int i = 0; i < numScans; ++i) {
                    theExternalKeysMap[i] = deserializeIntArray(in, serialVersion);
                }

                int numIn3bis = SerializationUtil.readSequenceLength(in);
                if (numIn3bis < 0) {
                    theIn3BindInfos = null;
                } else {
                    theIn3BindInfos = new In3BindInfo[numIn3bis];
                    for (int i = 0; i < numIn3bis; ++i) {
                        theIn3BindInfos[i] = new In3BindInfo(in, serialVersion);
                    }
                }
            } else {
                theExternalKeysIters = null;
                theExternalKeysMap = null;
                theIn3BindInfos = null;
            }
        }

       if (serialVersion >= QUERY_VERSION_6) {
           thePredIters = PlanIter.deserializeIters(in, serialVersion);
       } else {
           PlanIter filterIter = deserializeIter(in, serialVersion);
           thePredIters = new PlanIter[1];
           thePredIters[0] = filterIter;
       }

        theTupleRegs = deserializeIntArray(in, serialVersion);

        if (serialVersion < QUERY_VERSION_6) {
            theIndexResultReg = -1;
            theIndexTupleRegs = null;
        } else {
            theIndexResultReg = readPositiveInt(in, true);
            theIndexTupleRegs = deserializeIntArray(in, serialVersion);
        }
    }

    @Override
    public void writeFastExternal(DataOutput out, short serialVersion)
            throws IOException {

        super.writeFastExternal(out, serialVersion);

        SerializationUtil.writeString(out, serialVersion, theNamespace);

        if (serialVersion >= QUERY_VERSION_6) {
            PlanIter.serializeStringArray(theTableNames, out, serialVersion);
            if (serialVersion >= QUERY_VERSION_9) {
                PlanIter.serializeStringArray(theTableAliases, out,
                                              serialVersion);
            }
            out.writeInt(theNumAncestors);
            out.writeInt(theNumDescendants);
        } else if (theTableNames.length == 1) {
            SerializationUtil.writeString(out, serialVersion, theTableNames[0]);
        } else {
            String QV6String =
                SerialVersion.getKVVersion(QUERY_VERSION_6).
                getNumericVersionString();

            throw new QueryException(
                "Cannot execute a query with a NESTED TABLES clause " +
                "at a server whose version is less than " +
                QV6String + "\nserialVersion = " + serialVersion +
                " expected version = " + QUERY_VERSION_6);
        }

        SerializationUtil.writeString(out, serialVersion, theIndexName);
        serializeFieldDef(theTypeDef, out, serialVersion);
        out.writeShort(theDirection.ordinal());

        if (theIndexName == null) {
            out.writeInt(thePrimKeys.length);
            for (RecordValueImpl pk : thePrimKeys) {
                serializeKey(pk, out, serialVersion);
            }
        } else {
            out.writeInt(theSecKeys.length);
            for (RecordValueImpl sk : theSecKeys) {
                serializeKey(sk, out, serialVersion);
            }
        }

        for (FieldRange fr : theRanges) {
            serializeFieldRange(fr, out, serialVersion);
        }

        if (serialVersion >= QUERY_VERSION_6) {
            PlanIter.serializeBooleanArray(theUsesCoveringIndex, out);
        } else {
            out.writeBoolean(theUsesCoveringIndex[0]);
        }

        out.writeBoolean(theEliminateIndexDups);
        out.writeBoolean(theIsUpdate);

        if (serialVersion >= QUERY_VERSION_7) {
            out.writeBoolean(theIsUpdate);
        }

        if (serialVersion < QUERY_VERSION_9) {

            int numScans = theRanges.length;

            thePushedExternals = new PlanIter[numScans][];

            for (int i = 0; i < numScans; ++i) {

                if (theExternalKeysMap == null) {
                    thePushedExternals[i] = null;
                } else {
                    int[] bindKey = theExternalKeysMap[i];
                    thePushedExternals[i] = new PlanIter[bindKey.length];
                    for (int j = 0; j < bindKey.length; ++j) {
                        thePushedExternals[i][j] =
                            (bindKey[j] >= 0 ?
                             theExternalKeysIters[bindKey[j]] :
                             null);
                    }
                }
            }

            for (int i = 0; i < numScans; ++i) {
                serializeIters(thePushedExternals[i], out, serialVersion);
            }

        } else {
            out.writeBoolean(theHaveINstartstopPreds);
            serializeIters(theExternalKeysIters, out, serialVersion);

            if (theExternalKeysIters != null) {

                for (int[] arr : theExternalKeysMap) {
                    PlanIter.serializeIntArray(arr, out, serialVersion);
                }

                SerializationUtil.writeArrayLength(out, theIn3BindInfos);
                if (theIn3BindInfos != null) {
                    for (int i = 0; i < theIn3BindInfos.length; ++i) {
                        theIn3BindInfos[i].writeFastExternal(out,
                                                             serialVersion);
                    }
                }
            }
        }

        if (serialVersion >= QUERY_VERSION_6) {
            serializeIters(thePredIters, out, serialVersion);
        } else if (thePredIters != null) {
            assert(thePredIters.length == 1);
            serializeIter(thePredIters[0], out, serialVersion);
        } else {
            serializeIter(null, out, serialVersion);
        }

        serializeIntArray(theTupleRegs, out, serialVersion);

        if (serialVersion >= QUERY_VERSION_6) {
            out.writeInt(theIndexResultReg);
            serializeIntArray(theIndexTupleRegs, out, serialVersion);
        } else {
            String QV6String =
                SerialVersion.getKVVersion(QUERY_VERSION_6).
                getNumericVersionString();

            throw new QueryException(
                "Cannot execute a query that uses a covering index or " +
                "applies index-filtering predicates at a server whose " +
                "version is less than " +
                QV6String + "\nserialVersion = " + serialVersion +
                " expected version = " + QUERY_VERSION_6);
        }
    }

    @Override
    public PlanIterKind getKind() {
        return PlanIterKind.TABLE;
    }

    @Override
    public int[] getTupleRegs() {
        return theTupleRegs;
    }

    public void setPredIter(int tablePos, PlanIter iter) {
        thePredIters[tablePos] = iter;
    }

    protected PlanIter getTargetTablePred() {
        if (thePredIters.length > 0) {
            return thePredIters[theNumAncestors];
        }
        return null;
    }

    public void setIndexRegs(int resultReg, int[] tupleRegs) {
        theIndexResultReg = resultReg;
        theIndexTupleRegs = tupleRegs;
    }

    @Override
    public void open(RuntimeControlBlock rcb) {

        PlanIter worker = rcb.getServerIterFactory().createTableIter(rcb, this);
        worker.open(rcb);
    }

    @Override
    public boolean next(RuntimeControlBlock rcb) {

        TableIterState state = (TableIterState)rcb.getState(theStatePos);

        if (state.theWorkerIter != null) {
            return state.theWorkerIter.next(rcb);
        }

        state.done();
        return false;
    }

    @Override
    public void reset(RuntimeControlBlock rcb) {

        TableIterState state = (TableIterState)rcb.getState(theStatePos);
        if (state.theWorkerIter != null) {
            state.theWorkerIter.reset(rcb);
        }
    }

    @Override
    public void close(RuntimeControlBlock rcb) {

        TableIterState state = (TableIterState)rcb.getState(theStatePos);
        if (state == null) {
            return;
        }

        if (state.theWorkerIter != null) {
            state.theWorkerIter.close(rcb);
        }

    }

    @Override
    protected void displayContent(
        StringBuilder sb,
        DisplayFormatter formatter,
        boolean verbose) {

        formatter.indent(sb);
        sb.append("\"target table\" : \"");
        sb.append(NameUtils.makeQualifiedName(theNamespace,
                                              theTableNames[theNumAncestors]));
        sb.append("\",\n");

        if (theTableAliases != null) {
            formatter.indent(sb);
            sb.append("\"row variable\" : \"");
            sb.append(theTableAliases[theNumAncestors]);
            sb.append("\",\n");
        }

        formatter.indent(sb);
        sb.append("\"index used\" : ");

        if (thePrimKeys != null) {
            sb.append("\"primary index\",\n");
        } else {
            sb.append("\"").append(theIndexName).append("\",\n");
        }

        formatter.indent(sb);
        sb.append("\"covering index\" : ");
        sb.append(theUsesCoveringIndex[theNumAncestors]);
        sb.append(",\n");

        if (theIndexTupleRegs != null) {
            formatter.indent(sb);
            sb.append("\"index row variable\" : \"");
            sb.append(theTableAliases[theNumAncestors] + "_idx");
            sb.append("\",\n");
        }

        if (thePrimKeys != null) {
            displayIndexScans(sb, formatter, thePrimKeys);
        } else {
            displayIndexScans(sb, formatter, theSecKeys);
        }

        if (theEliminateIndexDups) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"duplicate elimination\" : true");
        }

        if (theExternalKeysIters != null) {
            sb.append(",\n");
            displayPushedExternals(sb, formatter, verbose);
        }

        if (theNumAncestors > 0) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"ancestor tables\" : [\n");
            formatter.incIndent();
            for (int i = 0; i < theNumAncestors; ++i) {
                formatter.indent(sb);
                sb.append("{ \"table\" : \"").append(theTableNames[i]);
                if (theTableAliases != null) {
                    sb.append("\", \"row variable\" : \"").append(theTableAliases[i]);
                }
                sb.append("\", \"covering primary index\" : ");
                sb.append(theUsesCoveringIndex[i]).append(" }");
                if (i < theNumAncestors - 1) {
                    sb.append(",\n");
                }
            }
            formatter.decIndent();
            formatter.indent(sb);
            sb.append("]");
        }

        if (theNumDescendants > 0) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"descendant tables\" : [\n");
            formatter.incIndent();
            for (int i = theNumAncestors + 1; i < theTableNames.length; ++i) {
                formatter.indent(sb);
                sb.append("{ \"table\" : \"").append(theTableNames[i]);
                if (theTableAliases != null) {
                    sb.append("\", \"row variable\" : \"").append(theTableAliases[i]);
                }
                sb.append("\", \"covering primary index\" : ");
                sb.append(theUsesCoveringIndex[i]).append(" }");
                if (i < theTableNames.length - 1) {
                    sb.append(",\n");
                }
            }
            formatter.decIndent();
            sb.append("\n");
            formatter.indent(sb);
            sb.append("]");
        }

        if (thePredIters != null) {

            if (thePredIters[theNumAncestors] != null) {
                sb.append(",\n");
                formatter.indent(sb);
                sb.append("\"index filtering predicate\" :\n");
                thePredIters[theNumAncestors].display(sb, formatter, verbose);
            }

            for (int i = 0; i < theTableNames.length; ++i) {

                if (i == theNumAncestors || thePredIters[i] == null) {
                    continue;
                }

                sb.append(",\n");
                formatter.indent(sb);
                sb.append("\"ON Predicate for table ");
                sb.append(theTableNames[i]).append("\" : \n");
                thePredIters[i].display(sb, formatter, verbose);
            }
        }
    }

    void displayIndexScans(
        StringBuilder sb,
        DisplayFormatter formatter,
        RecordValueImpl[] keys) {

            formatter.indent(sb);
            sb.append("\"index scans\" : [\n");
            formatter.incIndent();

            for (int i = 0; i < theRanges.length; ++i) {

                formatter.indent(sb);
                sb.append("{\n");
                formatter.incIndent();

                formatter.indent(sb);
                sb.append("\"equality conditions\" : ");
                sb.append(keys[i]);
                sb.append(",\n");
                formatter.indent(sb);
                sb.append("\"range conditions\" : ");
                if (theRanges[i] == null) {
                    sb.append("{}");
                } else {
                    theRanges[i].display(sb);
                }
                sb.append("\n");

                formatter.decIndent();
                formatter.indent(sb);
                sb.append("}");

                if (i < theRanges.length - 1) {
                    sb.append(",");
                }
                sb.append("\n");
            }

            formatter.decIndent();
            formatter.indent(sb);
            sb.append("]");
    }

    private void displayPushedExternals(
        StringBuilder sb,
        DisplayFormatter formatter,
        boolean verbose) {

        formatter.indent(sb);
        sb.append("\"key bind expressions\" : [\n");

        formatter.incIndent();
        for (int i = 0; i < theExternalKeysIters.length; ++i) {

            PlanIter iter = theExternalKeysIters[i];
            if (iter != null) {
                iter.display(sb, formatter, verbose);
            } else {
                formatter.indent(sb);
                sb.append("null");
            }
            if (i < theExternalKeysIters.length - 1) {
                sb.append(",\n");
            }
        }
        formatter.decIndent();
        sb.append("\n");
        formatter.indent(sb);
        sb.append("],\n");

        formatter.indent(sb);
        sb.append("\"map of key bind expressions\" : [\n");

        formatter.incIndent();
        for (int i = 0; i < theExternalKeysMap.length; ++i) {
            int[] arr = theExternalKeysMap[i];
            formatter.indent(sb);
            sb.append(PlanIter.printIntArray(arr));
            if (i < theExternalKeysMap.length - 1) {
                sb.append(",\n");
            }
        }
        sb.append("\n");
        formatter.decIndent();
        formatter.indent(sb);
        sb.append("]");

        if (theIn3BindInfos != null) {

            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"bind info for in3 operator\" : [\n");

            formatter.incIndent();
            for (int i = 0; i < theIn3BindInfos.length; ++i) {
                formatter.indent(sb);
                theIn3BindInfos[i].display(sb, formatter);
                if (i < theIn3BindInfos.length - 1) {
                    sb.append(",\n");
                }
            }
            formatter.decIndent();
            sb.append("\n");
            formatter.indent(sb);
            sb.append("]");
        }
    }

    @Override
    void displayRegs(StringBuilder sb, DisplayFormatter formatter) {

        super.displayRegs(sb, formatter);

        if (theIndexTupleRegs != null) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"Index entry registers\" : ");
            sb.append("[ ").append(theIndexResultReg).append(", [ ");
            for (int i = 0; i < theIndexTupleRegs.length; ++i) {
                sb.append(theIndexTupleRegs[i]);
                if (i < theIndexTupleRegs.length - 1) {
                    sb.append(", ");
                }
            }
            sb.append(" ] ]");
        }
    }

    static protected FieldValueImpl castValueToIndexKey(
        TableImpl table,
        IndexImpl index,
        int keyPos,
        FieldValueImpl val,
        FuncCode opcode) {

        if (index != null) {
            return FuncCompOp.castConstInCompOp(
                index.getFieldDef(keyPos),
                index.getIndexPath(keyPos).isJson(), /*allowJsonNull*/
                false, /*nullable*/
                true, /*scalar*/
                val,
                opcode,
                false/*strict*/);
        }

        return FuncCompOp.castConstInCompOp(
            table.getPrimKeyColumnDef(keyPos),
            false, /*allowJsonNull*/
            false, /*nullable*/
            true, /*scalar*/
            val,
            opcode,
            false/*strict*/);
    }
}
